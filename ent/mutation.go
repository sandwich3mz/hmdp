// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"hmdp/ent/blog"
	"hmdp/ent/predicate"
	"hmdp/ent/seckillvoucher"
	"hmdp/ent/shop"
	"hmdp/ent/shoptype"
	"hmdp/ent/user"
	"hmdp/ent/voucher"
	"sync"
	"time"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeBlog           = "Blog"
	TypeSeckillVoucher = "SeckillVoucher"
	TypeShop           = "Shop"
	TypeShopType       = "ShopType"
	TypeUser           = "User"
	TypeVoucher        = "Voucher"
)

// BlogMutation represents an operation that mutates the Blog nodes in the graph.
type BlogMutation struct {
	config
	op            Op
	typ           string
	id            *int64
	shopId        *int64
	addshopId     *int64
	userId        *int64
	adduserId     *int64
	title         *string
	images        *string
	content       *string
	liked         *int
	addliked      *int
	comments      *int
	addcomments   *int
	createTime    *time.Time
	updateTime    *time.Time
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*Blog, error)
	predicates    []predicate.Blog
}

var _ ent.Mutation = (*BlogMutation)(nil)

// blogOption allows management of the mutation configuration using functional options.
type blogOption func(*BlogMutation)

// newBlogMutation creates new mutation for the Blog entity.
func newBlogMutation(c config, op Op, opts ...blogOption) *BlogMutation {
	m := &BlogMutation{
		config:        c,
		op:            op,
		typ:           TypeBlog,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withBlogID sets the ID field of the mutation.
func withBlogID(id int64) blogOption {
	return func(m *BlogMutation) {
		var (
			err   error
			once  sync.Once
			value *Blog
		)
		m.oldValue = func(ctx context.Context) (*Blog, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Blog.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withBlog sets the old Blog of the mutation.
func withBlog(node *Blog) blogOption {
	return func(m *BlogMutation) {
		m.oldValue = func(context.Context) (*Blog, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m BlogMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m BlogMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Blog entities.
func (m *BlogMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *BlogMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *BlogMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Blog.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetShopId sets the "shopId" field.
func (m *BlogMutation) SetShopId(i int64) {
	m.shopId = &i
	m.addshopId = nil
}

// ShopId returns the value of the "shopId" field in the mutation.
func (m *BlogMutation) ShopId() (r int64, exists bool) {
	v := m.shopId
	if v == nil {
		return
	}
	return *v, true
}

// OldShopId returns the old "shopId" field's value of the Blog entity.
// If the Blog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlogMutation) OldShopId(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldShopId is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldShopId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldShopId: %w", err)
	}
	return oldValue.ShopId, nil
}

// AddShopId adds i to the "shopId" field.
func (m *BlogMutation) AddShopId(i int64) {
	if m.addshopId != nil {
		*m.addshopId += i
	} else {
		m.addshopId = &i
	}
}

// AddedShopId returns the value that was added to the "shopId" field in this mutation.
func (m *BlogMutation) AddedShopId() (r int64, exists bool) {
	v := m.addshopId
	if v == nil {
		return
	}
	return *v, true
}

// ResetShopId resets all changes to the "shopId" field.
func (m *BlogMutation) ResetShopId() {
	m.shopId = nil
	m.addshopId = nil
}

// SetUserId sets the "userId" field.
func (m *BlogMutation) SetUserId(i int64) {
	m.userId = &i
	m.adduserId = nil
}

// UserId returns the value of the "userId" field in the mutation.
func (m *BlogMutation) UserId() (r int64, exists bool) {
	v := m.userId
	if v == nil {
		return
	}
	return *v, true
}

// OldUserId returns the old "userId" field's value of the Blog entity.
// If the Blog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlogMutation) OldUserId(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserId is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserId: %w", err)
	}
	return oldValue.UserId, nil
}

// AddUserId adds i to the "userId" field.
func (m *BlogMutation) AddUserId(i int64) {
	if m.adduserId != nil {
		*m.adduserId += i
	} else {
		m.adduserId = &i
	}
}

// AddedUserId returns the value that was added to the "userId" field in this mutation.
func (m *BlogMutation) AddedUserId() (r int64, exists bool) {
	v := m.adduserId
	if v == nil {
		return
	}
	return *v, true
}

// ResetUserId resets all changes to the "userId" field.
func (m *BlogMutation) ResetUserId() {
	m.userId = nil
	m.adduserId = nil
}

// SetTitle sets the "title" field.
func (m *BlogMutation) SetTitle(s string) {
	m.title = &s
}

// Title returns the value of the "title" field in the mutation.
func (m *BlogMutation) Title() (r string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the Blog entity.
// If the Blog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlogMutation) OldTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ResetTitle resets all changes to the "title" field.
func (m *BlogMutation) ResetTitle() {
	m.title = nil
}

// SetImages sets the "images" field.
func (m *BlogMutation) SetImages(s string) {
	m.images = &s
}

// Images returns the value of the "images" field in the mutation.
func (m *BlogMutation) Images() (r string, exists bool) {
	v := m.images
	if v == nil {
		return
	}
	return *v, true
}

// OldImages returns the old "images" field's value of the Blog entity.
// If the Blog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlogMutation) OldImages(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldImages is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldImages requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldImages: %w", err)
	}
	return oldValue.Images, nil
}

// ResetImages resets all changes to the "images" field.
func (m *BlogMutation) ResetImages() {
	m.images = nil
}

// SetContent sets the "content" field.
func (m *BlogMutation) SetContent(s string) {
	m.content = &s
}

// Content returns the value of the "content" field in the mutation.
func (m *BlogMutation) Content() (r string, exists bool) {
	v := m.content
	if v == nil {
		return
	}
	return *v, true
}

// OldContent returns the old "content" field's value of the Blog entity.
// If the Blog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlogMutation) OldContent(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldContent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldContent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldContent: %w", err)
	}
	return oldValue.Content, nil
}

// ResetContent resets all changes to the "content" field.
func (m *BlogMutation) ResetContent() {
	m.content = nil
}

// SetLiked sets the "liked" field.
func (m *BlogMutation) SetLiked(i int) {
	m.liked = &i
	m.addliked = nil
}

// Liked returns the value of the "liked" field in the mutation.
func (m *BlogMutation) Liked() (r int, exists bool) {
	v := m.liked
	if v == nil {
		return
	}
	return *v, true
}

// OldLiked returns the old "liked" field's value of the Blog entity.
// If the Blog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlogMutation) OldLiked(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLiked is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLiked requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLiked: %w", err)
	}
	return oldValue.Liked, nil
}

// AddLiked adds i to the "liked" field.
func (m *BlogMutation) AddLiked(i int) {
	if m.addliked != nil {
		*m.addliked += i
	} else {
		m.addliked = &i
	}
}

// AddedLiked returns the value that was added to the "liked" field in this mutation.
func (m *BlogMutation) AddedLiked() (r int, exists bool) {
	v := m.addliked
	if v == nil {
		return
	}
	return *v, true
}

// ResetLiked resets all changes to the "liked" field.
func (m *BlogMutation) ResetLiked() {
	m.liked = nil
	m.addliked = nil
}

// SetComments sets the "comments" field.
func (m *BlogMutation) SetComments(i int) {
	m.comments = &i
	m.addcomments = nil
}

// Comments returns the value of the "comments" field in the mutation.
func (m *BlogMutation) Comments() (r int, exists bool) {
	v := m.comments
	if v == nil {
		return
	}
	return *v, true
}

// OldComments returns the old "comments" field's value of the Blog entity.
// If the Blog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlogMutation) OldComments(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldComments is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldComments requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldComments: %w", err)
	}
	return oldValue.Comments, nil
}

// AddComments adds i to the "comments" field.
func (m *BlogMutation) AddComments(i int) {
	if m.addcomments != nil {
		*m.addcomments += i
	} else {
		m.addcomments = &i
	}
}

// AddedComments returns the value that was added to the "comments" field in this mutation.
func (m *BlogMutation) AddedComments() (r int, exists bool) {
	v := m.addcomments
	if v == nil {
		return
	}
	return *v, true
}

// ResetComments resets all changes to the "comments" field.
func (m *BlogMutation) ResetComments() {
	m.comments = nil
	m.addcomments = nil
}

// SetCreateTime sets the "createTime" field.
func (m *BlogMutation) SetCreateTime(t time.Time) {
	m.createTime = &t
}

// CreateTime returns the value of the "createTime" field in the mutation.
func (m *BlogMutation) CreateTime() (r time.Time, exists bool) {
	v := m.createTime
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "createTime" field's value of the Blog entity.
// If the Blog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlogMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "createTime" field.
func (m *BlogMutation) ResetCreateTime() {
	m.createTime = nil
}

// SetUpdateTime sets the "updateTime" field.
func (m *BlogMutation) SetUpdateTime(t time.Time) {
	m.updateTime = &t
}

// UpdateTime returns the value of the "updateTime" field in the mutation.
func (m *BlogMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.updateTime
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "updateTime" field's value of the Blog entity.
// If the Blog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlogMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "updateTime" field.
func (m *BlogMutation) ResetUpdateTime() {
	m.updateTime = nil
}

// Where appends a list predicates to the BlogMutation builder.
func (m *BlogMutation) Where(ps ...predicate.Blog) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the BlogMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *BlogMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Blog, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *BlogMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *BlogMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Blog).
func (m *BlogMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *BlogMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.shopId != nil {
		fields = append(fields, blog.FieldShopId)
	}
	if m.userId != nil {
		fields = append(fields, blog.FieldUserId)
	}
	if m.title != nil {
		fields = append(fields, blog.FieldTitle)
	}
	if m.images != nil {
		fields = append(fields, blog.FieldImages)
	}
	if m.content != nil {
		fields = append(fields, blog.FieldContent)
	}
	if m.liked != nil {
		fields = append(fields, blog.FieldLiked)
	}
	if m.comments != nil {
		fields = append(fields, blog.FieldComments)
	}
	if m.createTime != nil {
		fields = append(fields, blog.FieldCreateTime)
	}
	if m.updateTime != nil {
		fields = append(fields, blog.FieldUpdateTime)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *BlogMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case blog.FieldShopId:
		return m.ShopId()
	case blog.FieldUserId:
		return m.UserId()
	case blog.FieldTitle:
		return m.Title()
	case blog.FieldImages:
		return m.Images()
	case blog.FieldContent:
		return m.Content()
	case blog.FieldLiked:
		return m.Liked()
	case blog.FieldComments:
		return m.Comments()
	case blog.FieldCreateTime:
		return m.CreateTime()
	case blog.FieldUpdateTime:
		return m.UpdateTime()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *BlogMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case blog.FieldShopId:
		return m.OldShopId(ctx)
	case blog.FieldUserId:
		return m.OldUserId(ctx)
	case blog.FieldTitle:
		return m.OldTitle(ctx)
	case blog.FieldImages:
		return m.OldImages(ctx)
	case blog.FieldContent:
		return m.OldContent(ctx)
	case blog.FieldLiked:
		return m.OldLiked(ctx)
	case blog.FieldComments:
		return m.OldComments(ctx)
	case blog.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case blog.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	}
	return nil, fmt.Errorf("unknown Blog field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BlogMutation) SetField(name string, value ent.Value) error {
	switch name {
	case blog.FieldShopId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetShopId(v)
		return nil
	case blog.FieldUserId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserId(v)
		return nil
	case blog.FieldTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case blog.FieldImages:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetImages(v)
		return nil
	case blog.FieldContent:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetContent(v)
		return nil
	case blog.FieldLiked:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLiked(v)
		return nil
	case blog.FieldComments:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetComments(v)
		return nil
	case blog.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case blog.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	}
	return fmt.Errorf("unknown Blog field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *BlogMutation) AddedFields() []string {
	var fields []string
	if m.addshopId != nil {
		fields = append(fields, blog.FieldShopId)
	}
	if m.adduserId != nil {
		fields = append(fields, blog.FieldUserId)
	}
	if m.addliked != nil {
		fields = append(fields, blog.FieldLiked)
	}
	if m.addcomments != nil {
		fields = append(fields, blog.FieldComments)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *BlogMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case blog.FieldShopId:
		return m.AddedShopId()
	case blog.FieldUserId:
		return m.AddedUserId()
	case blog.FieldLiked:
		return m.AddedLiked()
	case blog.FieldComments:
		return m.AddedComments()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BlogMutation) AddField(name string, value ent.Value) error {
	switch name {
	case blog.FieldShopId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddShopId(v)
		return nil
	case blog.FieldUserId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUserId(v)
		return nil
	case blog.FieldLiked:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLiked(v)
		return nil
	case blog.FieldComments:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddComments(v)
		return nil
	}
	return fmt.Errorf("unknown Blog numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *BlogMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *BlogMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *BlogMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Blog nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *BlogMutation) ResetField(name string) error {
	switch name {
	case blog.FieldShopId:
		m.ResetShopId()
		return nil
	case blog.FieldUserId:
		m.ResetUserId()
		return nil
	case blog.FieldTitle:
		m.ResetTitle()
		return nil
	case blog.FieldImages:
		m.ResetImages()
		return nil
	case blog.FieldContent:
		m.ResetContent()
		return nil
	case blog.FieldLiked:
		m.ResetLiked()
		return nil
	case blog.FieldComments:
		m.ResetComments()
		return nil
	case blog.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case blog.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	}
	return fmt.Errorf("unknown Blog field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *BlogMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *BlogMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *BlogMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *BlogMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *BlogMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *BlogMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *BlogMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Blog unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *BlogMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Blog edge %s", name)
}

// SeckillVoucherMutation represents an operation that mutates the SeckillVoucher nodes in the graph.
type SeckillVoucherMutation struct {
	config
	op             Op
	typ            string
	id             *uint64
	stock          *uint64
	addstock       *int64
	begin_time     *time.Time
	end_time       *time.Time
	create_time    *time.Time
	update_time    *time.Time
	clearedFields  map[string]struct{}
	getForm        *uint64
	clearedgetForm bool
	done           bool
	oldValue       func(context.Context) (*SeckillVoucher, error)
	predicates     []predicate.SeckillVoucher
}

var _ ent.Mutation = (*SeckillVoucherMutation)(nil)

// seckillvoucherOption allows management of the mutation configuration using functional options.
type seckillvoucherOption func(*SeckillVoucherMutation)

// newSeckillVoucherMutation creates new mutation for the SeckillVoucher entity.
func newSeckillVoucherMutation(c config, op Op, opts ...seckillvoucherOption) *SeckillVoucherMutation {
	m := &SeckillVoucherMutation{
		config:        c,
		op:            op,
		typ:           TypeSeckillVoucher,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSeckillVoucherID sets the ID field of the mutation.
func withSeckillVoucherID(id uint64) seckillvoucherOption {
	return func(m *SeckillVoucherMutation) {
		var (
			err   error
			once  sync.Once
			value *SeckillVoucher
		)
		m.oldValue = func(ctx context.Context) (*SeckillVoucher, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().SeckillVoucher.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSeckillVoucher sets the old SeckillVoucher of the mutation.
func withSeckillVoucher(node *SeckillVoucher) seckillvoucherOption {
	return func(m *SeckillVoucherMutation) {
		m.oldValue = func(context.Context) (*SeckillVoucher, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SeckillVoucherMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SeckillVoucherMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of SeckillVoucher entities.
func (m *SeckillVoucherMutation) SetID(id uint64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SeckillVoucherMutation) ID() (id uint64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SeckillVoucherMutation) IDs(ctx context.Context) ([]uint64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().SeckillVoucher.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetVoucherID sets the "voucher_id" field.
func (m *SeckillVoucherMutation) SetVoucherID(u uint64) {
	m.getForm = &u
}

// VoucherID returns the value of the "voucher_id" field in the mutation.
func (m *SeckillVoucherMutation) VoucherID() (r uint64, exists bool) {
	v := m.getForm
	if v == nil {
		return
	}
	return *v, true
}

// OldVoucherID returns the old "voucher_id" field's value of the SeckillVoucher entity.
// If the SeckillVoucher object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SeckillVoucherMutation) OldVoucherID(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVoucherID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVoucherID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVoucherID: %w", err)
	}
	return oldValue.VoucherID, nil
}

// ResetVoucherID resets all changes to the "voucher_id" field.
func (m *SeckillVoucherMutation) ResetVoucherID() {
	m.getForm = nil
}

// SetStock sets the "stock" field.
func (m *SeckillVoucherMutation) SetStock(u uint64) {
	m.stock = &u
	m.addstock = nil
}

// Stock returns the value of the "stock" field in the mutation.
func (m *SeckillVoucherMutation) Stock() (r uint64, exists bool) {
	v := m.stock
	if v == nil {
		return
	}
	return *v, true
}

// OldStock returns the old "stock" field's value of the SeckillVoucher entity.
// If the SeckillVoucher object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SeckillVoucherMutation) OldStock(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStock is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStock requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStock: %w", err)
	}
	return oldValue.Stock, nil
}

// AddStock adds u to the "stock" field.
func (m *SeckillVoucherMutation) AddStock(u int64) {
	if m.addstock != nil {
		*m.addstock += u
	} else {
		m.addstock = &u
	}
}

// AddedStock returns the value that was added to the "stock" field in this mutation.
func (m *SeckillVoucherMutation) AddedStock() (r int64, exists bool) {
	v := m.addstock
	if v == nil {
		return
	}
	return *v, true
}

// ResetStock resets all changes to the "stock" field.
func (m *SeckillVoucherMutation) ResetStock() {
	m.stock = nil
	m.addstock = nil
}

// SetBeginTime sets the "begin_time" field.
func (m *SeckillVoucherMutation) SetBeginTime(t time.Time) {
	m.begin_time = &t
}

// BeginTime returns the value of the "begin_time" field in the mutation.
func (m *SeckillVoucherMutation) BeginTime() (r time.Time, exists bool) {
	v := m.begin_time
	if v == nil {
		return
	}
	return *v, true
}

// OldBeginTime returns the old "begin_time" field's value of the SeckillVoucher entity.
// If the SeckillVoucher object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SeckillVoucherMutation) OldBeginTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBeginTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBeginTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBeginTime: %w", err)
	}
	return oldValue.BeginTime, nil
}

// ResetBeginTime resets all changes to the "begin_time" field.
func (m *SeckillVoucherMutation) ResetBeginTime() {
	m.begin_time = nil
}

// SetEndTime sets the "end_time" field.
func (m *SeckillVoucherMutation) SetEndTime(t time.Time) {
	m.end_time = &t
}

// EndTime returns the value of the "end_time" field in the mutation.
func (m *SeckillVoucherMutation) EndTime() (r time.Time, exists bool) {
	v := m.end_time
	if v == nil {
		return
	}
	return *v, true
}

// OldEndTime returns the old "end_time" field's value of the SeckillVoucher entity.
// If the SeckillVoucher object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SeckillVoucherMutation) OldEndTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEndTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEndTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEndTime: %w", err)
	}
	return oldValue.EndTime, nil
}

// ResetEndTime resets all changes to the "end_time" field.
func (m *SeckillVoucherMutation) ResetEndTime() {
	m.end_time = nil
}

// SetCreateTime sets the "create_time" field.
func (m *SeckillVoucherMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *SeckillVoucherMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the SeckillVoucher entity.
// If the SeckillVoucher object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SeckillVoucherMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *SeckillVoucherMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *SeckillVoucherMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *SeckillVoucherMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the SeckillVoucher entity.
// If the SeckillVoucher object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SeckillVoucherMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *SeckillVoucherMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetGetFormID sets the "getForm" edge to the Voucher entity by id.
func (m *SeckillVoucherMutation) SetGetFormID(id uint64) {
	m.getForm = &id
}

// ClearGetForm clears the "getForm" edge to the Voucher entity.
func (m *SeckillVoucherMutation) ClearGetForm() {
	m.clearedgetForm = true
}

// GetFormCleared reports if the "getForm" edge to the Voucher entity was cleared.
func (m *SeckillVoucherMutation) GetFormCleared() bool {
	return m.clearedgetForm
}

// GetFormID returns the "getForm" edge ID in the mutation.
func (m *SeckillVoucherMutation) GetFormID() (id uint64, exists bool) {
	if m.getForm != nil {
		return *m.getForm, true
	}
	return
}

// GetFormIDs returns the "getForm" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// GetFormID instead. It exists only for internal usage by the builders.
func (m *SeckillVoucherMutation) GetFormIDs() (ids []uint64) {
	if id := m.getForm; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetGetForm resets all changes to the "getForm" edge.
func (m *SeckillVoucherMutation) ResetGetForm() {
	m.getForm = nil
	m.clearedgetForm = false
}

// Where appends a list predicates to the SeckillVoucherMutation builder.
func (m *SeckillVoucherMutation) Where(ps ...predicate.SeckillVoucher) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the SeckillVoucherMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *SeckillVoucherMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.SeckillVoucher, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *SeckillVoucherMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *SeckillVoucherMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (SeckillVoucher).
func (m *SeckillVoucherMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SeckillVoucherMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.getForm != nil {
		fields = append(fields, seckillvoucher.FieldVoucherID)
	}
	if m.stock != nil {
		fields = append(fields, seckillvoucher.FieldStock)
	}
	if m.begin_time != nil {
		fields = append(fields, seckillvoucher.FieldBeginTime)
	}
	if m.end_time != nil {
		fields = append(fields, seckillvoucher.FieldEndTime)
	}
	if m.create_time != nil {
		fields = append(fields, seckillvoucher.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, seckillvoucher.FieldUpdateTime)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SeckillVoucherMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case seckillvoucher.FieldVoucherID:
		return m.VoucherID()
	case seckillvoucher.FieldStock:
		return m.Stock()
	case seckillvoucher.FieldBeginTime:
		return m.BeginTime()
	case seckillvoucher.FieldEndTime:
		return m.EndTime()
	case seckillvoucher.FieldCreateTime:
		return m.CreateTime()
	case seckillvoucher.FieldUpdateTime:
		return m.UpdateTime()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SeckillVoucherMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case seckillvoucher.FieldVoucherID:
		return m.OldVoucherID(ctx)
	case seckillvoucher.FieldStock:
		return m.OldStock(ctx)
	case seckillvoucher.FieldBeginTime:
		return m.OldBeginTime(ctx)
	case seckillvoucher.FieldEndTime:
		return m.OldEndTime(ctx)
	case seckillvoucher.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case seckillvoucher.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	}
	return nil, fmt.Errorf("unknown SeckillVoucher field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SeckillVoucherMutation) SetField(name string, value ent.Value) error {
	switch name {
	case seckillvoucher.FieldVoucherID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVoucherID(v)
		return nil
	case seckillvoucher.FieldStock:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStock(v)
		return nil
	case seckillvoucher.FieldBeginTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBeginTime(v)
		return nil
	case seckillvoucher.FieldEndTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEndTime(v)
		return nil
	case seckillvoucher.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case seckillvoucher.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	}
	return fmt.Errorf("unknown SeckillVoucher field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SeckillVoucherMutation) AddedFields() []string {
	var fields []string
	if m.addstock != nil {
		fields = append(fields, seckillvoucher.FieldStock)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SeckillVoucherMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case seckillvoucher.FieldStock:
		return m.AddedStock()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SeckillVoucherMutation) AddField(name string, value ent.Value) error {
	switch name {
	case seckillvoucher.FieldStock:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStock(v)
		return nil
	}
	return fmt.Errorf("unknown SeckillVoucher numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SeckillVoucherMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SeckillVoucherMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SeckillVoucherMutation) ClearField(name string) error {
	return fmt.Errorf("unknown SeckillVoucher nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SeckillVoucherMutation) ResetField(name string) error {
	switch name {
	case seckillvoucher.FieldVoucherID:
		m.ResetVoucherID()
		return nil
	case seckillvoucher.FieldStock:
		m.ResetStock()
		return nil
	case seckillvoucher.FieldBeginTime:
		m.ResetBeginTime()
		return nil
	case seckillvoucher.FieldEndTime:
		m.ResetEndTime()
		return nil
	case seckillvoucher.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case seckillvoucher.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	}
	return fmt.Errorf("unknown SeckillVoucher field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SeckillVoucherMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.getForm != nil {
		edges = append(edges, seckillvoucher.EdgeGetForm)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SeckillVoucherMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case seckillvoucher.EdgeGetForm:
		if id := m.getForm; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SeckillVoucherMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SeckillVoucherMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SeckillVoucherMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedgetForm {
		edges = append(edges, seckillvoucher.EdgeGetForm)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SeckillVoucherMutation) EdgeCleared(name string) bool {
	switch name {
	case seckillvoucher.EdgeGetForm:
		return m.clearedgetForm
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SeckillVoucherMutation) ClearEdge(name string) error {
	switch name {
	case seckillvoucher.EdgeGetForm:
		m.ClearGetForm()
		return nil
	}
	return fmt.Errorf("unknown SeckillVoucher unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SeckillVoucherMutation) ResetEdge(name string) error {
	switch name {
	case seckillvoucher.EdgeGetForm:
		m.ResetGetForm()
		return nil
	}
	return fmt.Errorf("unknown SeckillVoucher edge %s", name)
}

// ShopMutation represents an operation that mutates the Shop nodes in the graph.
type ShopMutation struct {
	config
	op            Op
	typ           string
	id            *int64
	name          *string
	type_id       *uint64
	addtype_id    *int64
	images        *string
	area          *string
	address       *string
	x             *float64
	addx          *float64
	y             *float64
	addy          *float64
	avg_price     *uint64
	addavg_price  *int64
	sold          *uint64
	addsold       *int64
	comments      *uint64
	addcomments   *int64
	score         *int8
	addscore      *int8
	open_hours    *string
	createTime    *time.Time
	updateTime    *time.Time
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*Shop, error)
	predicates    []predicate.Shop
}

var _ ent.Mutation = (*ShopMutation)(nil)

// shopOption allows management of the mutation configuration using functional options.
type shopOption func(*ShopMutation)

// newShopMutation creates new mutation for the Shop entity.
func newShopMutation(c config, op Op, opts ...shopOption) *ShopMutation {
	m := &ShopMutation{
		config:        c,
		op:            op,
		typ:           TypeShop,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withShopID sets the ID field of the mutation.
func withShopID(id int64) shopOption {
	return func(m *ShopMutation) {
		var (
			err   error
			once  sync.Once
			value *Shop
		)
		m.oldValue = func(ctx context.Context) (*Shop, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Shop.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withShop sets the old Shop of the mutation.
func withShop(node *Shop) shopOption {
	return func(m *ShopMutation) {
		m.oldValue = func(context.Context) (*Shop, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ShopMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ShopMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Shop entities.
func (m *ShopMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ShopMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ShopMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Shop.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *ShopMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *ShopMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Shop entity.
// If the Shop object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ShopMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *ShopMutation) ResetName() {
	m.name = nil
}

// SetTypeID sets the "type_id" field.
func (m *ShopMutation) SetTypeID(u uint64) {
	m.type_id = &u
	m.addtype_id = nil
}

// TypeID returns the value of the "type_id" field in the mutation.
func (m *ShopMutation) TypeID() (r uint64, exists bool) {
	v := m.type_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTypeID returns the old "type_id" field's value of the Shop entity.
// If the Shop object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ShopMutation) OldTypeID(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTypeID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTypeID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTypeID: %w", err)
	}
	return oldValue.TypeID, nil
}

// AddTypeID adds u to the "type_id" field.
func (m *ShopMutation) AddTypeID(u int64) {
	if m.addtype_id != nil {
		*m.addtype_id += u
	} else {
		m.addtype_id = &u
	}
}

// AddedTypeID returns the value that was added to the "type_id" field in this mutation.
func (m *ShopMutation) AddedTypeID() (r int64, exists bool) {
	v := m.addtype_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetTypeID resets all changes to the "type_id" field.
func (m *ShopMutation) ResetTypeID() {
	m.type_id = nil
	m.addtype_id = nil
}

// SetImages sets the "images" field.
func (m *ShopMutation) SetImages(s string) {
	m.images = &s
}

// Images returns the value of the "images" field in the mutation.
func (m *ShopMutation) Images() (r string, exists bool) {
	v := m.images
	if v == nil {
		return
	}
	return *v, true
}

// OldImages returns the old "images" field's value of the Shop entity.
// If the Shop object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ShopMutation) OldImages(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldImages is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldImages requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldImages: %w", err)
	}
	return oldValue.Images, nil
}

// ResetImages resets all changes to the "images" field.
func (m *ShopMutation) ResetImages() {
	m.images = nil
}

// SetArea sets the "area" field.
func (m *ShopMutation) SetArea(s string) {
	m.area = &s
}

// Area returns the value of the "area" field in the mutation.
func (m *ShopMutation) Area() (r string, exists bool) {
	v := m.area
	if v == nil {
		return
	}
	return *v, true
}

// OldArea returns the old "area" field's value of the Shop entity.
// If the Shop object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ShopMutation) OldArea(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldArea is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldArea requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldArea: %w", err)
	}
	return oldValue.Area, nil
}

// ResetArea resets all changes to the "area" field.
func (m *ShopMutation) ResetArea() {
	m.area = nil
}

// SetAddress sets the "address" field.
func (m *ShopMutation) SetAddress(s string) {
	m.address = &s
}

// Address returns the value of the "address" field in the mutation.
func (m *ShopMutation) Address() (r string, exists bool) {
	v := m.address
	if v == nil {
		return
	}
	return *v, true
}

// OldAddress returns the old "address" field's value of the Shop entity.
// If the Shop object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ShopMutation) OldAddress(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAddress is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAddress requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAddress: %w", err)
	}
	return oldValue.Address, nil
}

// ResetAddress resets all changes to the "address" field.
func (m *ShopMutation) ResetAddress() {
	m.address = nil
}

// SetX sets the "x" field.
func (m *ShopMutation) SetX(f float64) {
	m.x = &f
	m.addx = nil
}

// X returns the value of the "x" field in the mutation.
func (m *ShopMutation) X() (r float64, exists bool) {
	v := m.x
	if v == nil {
		return
	}
	return *v, true
}

// OldX returns the old "x" field's value of the Shop entity.
// If the Shop object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ShopMutation) OldX(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldX is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldX requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldX: %w", err)
	}
	return oldValue.X, nil
}

// AddX adds f to the "x" field.
func (m *ShopMutation) AddX(f float64) {
	if m.addx != nil {
		*m.addx += f
	} else {
		m.addx = &f
	}
}

// AddedX returns the value that was added to the "x" field in this mutation.
func (m *ShopMutation) AddedX() (r float64, exists bool) {
	v := m.addx
	if v == nil {
		return
	}
	return *v, true
}

// ResetX resets all changes to the "x" field.
func (m *ShopMutation) ResetX() {
	m.x = nil
	m.addx = nil
}

// SetY sets the "y" field.
func (m *ShopMutation) SetY(f float64) {
	m.y = &f
	m.addy = nil
}

// Y returns the value of the "y" field in the mutation.
func (m *ShopMutation) Y() (r float64, exists bool) {
	v := m.y
	if v == nil {
		return
	}
	return *v, true
}

// OldY returns the old "y" field's value of the Shop entity.
// If the Shop object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ShopMutation) OldY(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldY is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldY requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldY: %w", err)
	}
	return oldValue.Y, nil
}

// AddY adds f to the "y" field.
func (m *ShopMutation) AddY(f float64) {
	if m.addy != nil {
		*m.addy += f
	} else {
		m.addy = &f
	}
}

// AddedY returns the value that was added to the "y" field in this mutation.
func (m *ShopMutation) AddedY() (r float64, exists bool) {
	v := m.addy
	if v == nil {
		return
	}
	return *v, true
}

// ResetY resets all changes to the "y" field.
func (m *ShopMutation) ResetY() {
	m.y = nil
	m.addy = nil
}

// SetAvgPrice sets the "avg_price" field.
func (m *ShopMutation) SetAvgPrice(u uint64) {
	m.avg_price = &u
	m.addavg_price = nil
}

// AvgPrice returns the value of the "avg_price" field in the mutation.
func (m *ShopMutation) AvgPrice() (r uint64, exists bool) {
	v := m.avg_price
	if v == nil {
		return
	}
	return *v, true
}

// OldAvgPrice returns the old "avg_price" field's value of the Shop entity.
// If the Shop object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ShopMutation) OldAvgPrice(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAvgPrice is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAvgPrice requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAvgPrice: %w", err)
	}
	return oldValue.AvgPrice, nil
}

// AddAvgPrice adds u to the "avg_price" field.
func (m *ShopMutation) AddAvgPrice(u int64) {
	if m.addavg_price != nil {
		*m.addavg_price += u
	} else {
		m.addavg_price = &u
	}
}

// AddedAvgPrice returns the value that was added to the "avg_price" field in this mutation.
func (m *ShopMutation) AddedAvgPrice() (r int64, exists bool) {
	v := m.addavg_price
	if v == nil {
		return
	}
	return *v, true
}

// ResetAvgPrice resets all changes to the "avg_price" field.
func (m *ShopMutation) ResetAvgPrice() {
	m.avg_price = nil
	m.addavg_price = nil
}

// SetSold sets the "sold" field.
func (m *ShopMutation) SetSold(u uint64) {
	m.sold = &u
	m.addsold = nil
}

// Sold returns the value of the "sold" field in the mutation.
func (m *ShopMutation) Sold() (r uint64, exists bool) {
	v := m.sold
	if v == nil {
		return
	}
	return *v, true
}

// OldSold returns the old "sold" field's value of the Shop entity.
// If the Shop object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ShopMutation) OldSold(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSold is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSold requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSold: %w", err)
	}
	return oldValue.Sold, nil
}

// AddSold adds u to the "sold" field.
func (m *ShopMutation) AddSold(u int64) {
	if m.addsold != nil {
		*m.addsold += u
	} else {
		m.addsold = &u
	}
}

// AddedSold returns the value that was added to the "sold" field in this mutation.
func (m *ShopMutation) AddedSold() (r int64, exists bool) {
	v := m.addsold
	if v == nil {
		return
	}
	return *v, true
}

// ResetSold resets all changes to the "sold" field.
func (m *ShopMutation) ResetSold() {
	m.sold = nil
	m.addsold = nil
}

// SetComments sets the "comments" field.
func (m *ShopMutation) SetComments(u uint64) {
	m.comments = &u
	m.addcomments = nil
}

// Comments returns the value of the "comments" field in the mutation.
func (m *ShopMutation) Comments() (r uint64, exists bool) {
	v := m.comments
	if v == nil {
		return
	}
	return *v, true
}

// OldComments returns the old "comments" field's value of the Shop entity.
// If the Shop object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ShopMutation) OldComments(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldComments is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldComments requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldComments: %w", err)
	}
	return oldValue.Comments, nil
}

// AddComments adds u to the "comments" field.
func (m *ShopMutation) AddComments(u int64) {
	if m.addcomments != nil {
		*m.addcomments += u
	} else {
		m.addcomments = &u
	}
}

// AddedComments returns the value that was added to the "comments" field in this mutation.
func (m *ShopMutation) AddedComments() (r int64, exists bool) {
	v := m.addcomments
	if v == nil {
		return
	}
	return *v, true
}

// ResetComments resets all changes to the "comments" field.
func (m *ShopMutation) ResetComments() {
	m.comments = nil
	m.addcomments = nil
}

// SetScore sets the "score" field.
func (m *ShopMutation) SetScore(i int8) {
	m.score = &i
	m.addscore = nil
}

// Score returns the value of the "score" field in the mutation.
func (m *ShopMutation) Score() (r int8, exists bool) {
	v := m.score
	if v == nil {
		return
	}
	return *v, true
}

// OldScore returns the old "score" field's value of the Shop entity.
// If the Shop object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ShopMutation) OldScore(ctx context.Context) (v int8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldScore is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldScore requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldScore: %w", err)
	}
	return oldValue.Score, nil
}

// AddScore adds i to the "score" field.
func (m *ShopMutation) AddScore(i int8) {
	if m.addscore != nil {
		*m.addscore += i
	} else {
		m.addscore = &i
	}
}

// AddedScore returns the value that was added to the "score" field in this mutation.
func (m *ShopMutation) AddedScore() (r int8, exists bool) {
	v := m.addscore
	if v == nil {
		return
	}
	return *v, true
}

// ResetScore resets all changes to the "score" field.
func (m *ShopMutation) ResetScore() {
	m.score = nil
	m.addscore = nil
}

// SetOpenHours sets the "open_hours" field.
func (m *ShopMutation) SetOpenHours(s string) {
	m.open_hours = &s
}

// OpenHours returns the value of the "open_hours" field in the mutation.
func (m *ShopMutation) OpenHours() (r string, exists bool) {
	v := m.open_hours
	if v == nil {
		return
	}
	return *v, true
}

// OldOpenHours returns the old "open_hours" field's value of the Shop entity.
// If the Shop object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ShopMutation) OldOpenHours(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOpenHours is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOpenHours requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOpenHours: %w", err)
	}
	return oldValue.OpenHours, nil
}

// ResetOpenHours resets all changes to the "open_hours" field.
func (m *ShopMutation) ResetOpenHours() {
	m.open_hours = nil
}

// SetCreateTime sets the "createTime" field.
func (m *ShopMutation) SetCreateTime(t time.Time) {
	m.createTime = &t
}

// CreateTime returns the value of the "createTime" field in the mutation.
func (m *ShopMutation) CreateTime() (r time.Time, exists bool) {
	v := m.createTime
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "createTime" field's value of the Shop entity.
// If the Shop object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ShopMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "createTime" field.
func (m *ShopMutation) ResetCreateTime() {
	m.createTime = nil
}

// SetUpdateTime sets the "updateTime" field.
func (m *ShopMutation) SetUpdateTime(t time.Time) {
	m.updateTime = &t
}

// UpdateTime returns the value of the "updateTime" field in the mutation.
func (m *ShopMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.updateTime
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "updateTime" field's value of the Shop entity.
// If the Shop object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ShopMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "updateTime" field.
func (m *ShopMutation) ResetUpdateTime() {
	m.updateTime = nil
}

// Where appends a list predicates to the ShopMutation builder.
func (m *ShopMutation) Where(ps ...predicate.Shop) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ShopMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ShopMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Shop, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ShopMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ShopMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Shop).
func (m *ShopMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ShopMutation) Fields() []string {
	fields := make([]string, 0, 14)
	if m.name != nil {
		fields = append(fields, shop.FieldName)
	}
	if m.type_id != nil {
		fields = append(fields, shop.FieldTypeID)
	}
	if m.images != nil {
		fields = append(fields, shop.FieldImages)
	}
	if m.area != nil {
		fields = append(fields, shop.FieldArea)
	}
	if m.address != nil {
		fields = append(fields, shop.FieldAddress)
	}
	if m.x != nil {
		fields = append(fields, shop.FieldX)
	}
	if m.y != nil {
		fields = append(fields, shop.FieldY)
	}
	if m.avg_price != nil {
		fields = append(fields, shop.FieldAvgPrice)
	}
	if m.sold != nil {
		fields = append(fields, shop.FieldSold)
	}
	if m.comments != nil {
		fields = append(fields, shop.FieldComments)
	}
	if m.score != nil {
		fields = append(fields, shop.FieldScore)
	}
	if m.open_hours != nil {
		fields = append(fields, shop.FieldOpenHours)
	}
	if m.createTime != nil {
		fields = append(fields, shop.FieldCreateTime)
	}
	if m.updateTime != nil {
		fields = append(fields, shop.FieldUpdateTime)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ShopMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case shop.FieldName:
		return m.Name()
	case shop.FieldTypeID:
		return m.TypeID()
	case shop.FieldImages:
		return m.Images()
	case shop.FieldArea:
		return m.Area()
	case shop.FieldAddress:
		return m.Address()
	case shop.FieldX:
		return m.X()
	case shop.FieldY:
		return m.Y()
	case shop.FieldAvgPrice:
		return m.AvgPrice()
	case shop.FieldSold:
		return m.Sold()
	case shop.FieldComments:
		return m.Comments()
	case shop.FieldScore:
		return m.Score()
	case shop.FieldOpenHours:
		return m.OpenHours()
	case shop.FieldCreateTime:
		return m.CreateTime()
	case shop.FieldUpdateTime:
		return m.UpdateTime()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ShopMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case shop.FieldName:
		return m.OldName(ctx)
	case shop.FieldTypeID:
		return m.OldTypeID(ctx)
	case shop.FieldImages:
		return m.OldImages(ctx)
	case shop.FieldArea:
		return m.OldArea(ctx)
	case shop.FieldAddress:
		return m.OldAddress(ctx)
	case shop.FieldX:
		return m.OldX(ctx)
	case shop.FieldY:
		return m.OldY(ctx)
	case shop.FieldAvgPrice:
		return m.OldAvgPrice(ctx)
	case shop.FieldSold:
		return m.OldSold(ctx)
	case shop.FieldComments:
		return m.OldComments(ctx)
	case shop.FieldScore:
		return m.OldScore(ctx)
	case shop.FieldOpenHours:
		return m.OldOpenHours(ctx)
	case shop.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case shop.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	}
	return nil, fmt.Errorf("unknown Shop field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ShopMutation) SetField(name string, value ent.Value) error {
	switch name {
	case shop.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case shop.FieldTypeID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTypeID(v)
		return nil
	case shop.FieldImages:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetImages(v)
		return nil
	case shop.FieldArea:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetArea(v)
		return nil
	case shop.FieldAddress:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAddress(v)
		return nil
	case shop.FieldX:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetX(v)
		return nil
	case shop.FieldY:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetY(v)
		return nil
	case shop.FieldAvgPrice:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAvgPrice(v)
		return nil
	case shop.FieldSold:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSold(v)
		return nil
	case shop.FieldComments:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetComments(v)
		return nil
	case shop.FieldScore:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetScore(v)
		return nil
	case shop.FieldOpenHours:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOpenHours(v)
		return nil
	case shop.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case shop.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	}
	return fmt.Errorf("unknown Shop field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ShopMutation) AddedFields() []string {
	var fields []string
	if m.addtype_id != nil {
		fields = append(fields, shop.FieldTypeID)
	}
	if m.addx != nil {
		fields = append(fields, shop.FieldX)
	}
	if m.addy != nil {
		fields = append(fields, shop.FieldY)
	}
	if m.addavg_price != nil {
		fields = append(fields, shop.FieldAvgPrice)
	}
	if m.addsold != nil {
		fields = append(fields, shop.FieldSold)
	}
	if m.addcomments != nil {
		fields = append(fields, shop.FieldComments)
	}
	if m.addscore != nil {
		fields = append(fields, shop.FieldScore)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ShopMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case shop.FieldTypeID:
		return m.AddedTypeID()
	case shop.FieldX:
		return m.AddedX()
	case shop.FieldY:
		return m.AddedY()
	case shop.FieldAvgPrice:
		return m.AddedAvgPrice()
	case shop.FieldSold:
		return m.AddedSold()
	case shop.FieldComments:
		return m.AddedComments()
	case shop.FieldScore:
		return m.AddedScore()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ShopMutation) AddField(name string, value ent.Value) error {
	switch name {
	case shop.FieldTypeID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTypeID(v)
		return nil
	case shop.FieldX:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddX(v)
		return nil
	case shop.FieldY:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddY(v)
		return nil
	case shop.FieldAvgPrice:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAvgPrice(v)
		return nil
	case shop.FieldSold:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSold(v)
		return nil
	case shop.FieldComments:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddComments(v)
		return nil
	case shop.FieldScore:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddScore(v)
		return nil
	}
	return fmt.Errorf("unknown Shop numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ShopMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ShopMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ShopMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Shop nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ShopMutation) ResetField(name string) error {
	switch name {
	case shop.FieldName:
		m.ResetName()
		return nil
	case shop.FieldTypeID:
		m.ResetTypeID()
		return nil
	case shop.FieldImages:
		m.ResetImages()
		return nil
	case shop.FieldArea:
		m.ResetArea()
		return nil
	case shop.FieldAddress:
		m.ResetAddress()
		return nil
	case shop.FieldX:
		m.ResetX()
		return nil
	case shop.FieldY:
		m.ResetY()
		return nil
	case shop.FieldAvgPrice:
		m.ResetAvgPrice()
		return nil
	case shop.FieldSold:
		m.ResetSold()
		return nil
	case shop.FieldComments:
		m.ResetComments()
		return nil
	case shop.FieldScore:
		m.ResetScore()
		return nil
	case shop.FieldOpenHours:
		m.ResetOpenHours()
		return nil
	case shop.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case shop.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	}
	return fmt.Errorf("unknown Shop field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ShopMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ShopMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ShopMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ShopMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ShopMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ShopMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ShopMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Shop unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ShopMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Shop edge %s", name)
}

// ShopTypeMutation represents an operation that mutates the ShopType nodes in the graph.
type ShopTypeMutation struct {
	config
	op            Op
	typ           string
	id            *int64
	name          *string
	icon          *string
	sort          *int
	addsort       *int
	createTime    *time.Time
	updateTime    *time.Time
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*ShopType, error)
	predicates    []predicate.ShopType
}

var _ ent.Mutation = (*ShopTypeMutation)(nil)

// shoptypeOption allows management of the mutation configuration using functional options.
type shoptypeOption func(*ShopTypeMutation)

// newShopTypeMutation creates new mutation for the ShopType entity.
func newShopTypeMutation(c config, op Op, opts ...shoptypeOption) *ShopTypeMutation {
	m := &ShopTypeMutation{
		config:        c,
		op:            op,
		typ:           TypeShopType,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withShopTypeID sets the ID field of the mutation.
func withShopTypeID(id int64) shoptypeOption {
	return func(m *ShopTypeMutation) {
		var (
			err   error
			once  sync.Once
			value *ShopType
		)
		m.oldValue = func(ctx context.Context) (*ShopType, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ShopType.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withShopType sets the old ShopType of the mutation.
func withShopType(node *ShopType) shoptypeOption {
	return func(m *ShopTypeMutation) {
		m.oldValue = func(context.Context) (*ShopType, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ShopTypeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ShopTypeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of ShopType entities.
func (m *ShopTypeMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ShopTypeMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ShopTypeMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ShopType.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *ShopTypeMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *ShopTypeMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the ShopType entity.
// If the ShopType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ShopTypeMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *ShopTypeMutation) ResetName() {
	m.name = nil
}

// SetIcon sets the "icon" field.
func (m *ShopTypeMutation) SetIcon(s string) {
	m.icon = &s
}

// Icon returns the value of the "icon" field in the mutation.
func (m *ShopTypeMutation) Icon() (r string, exists bool) {
	v := m.icon
	if v == nil {
		return
	}
	return *v, true
}

// OldIcon returns the old "icon" field's value of the ShopType entity.
// If the ShopType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ShopTypeMutation) OldIcon(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIcon is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIcon requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIcon: %w", err)
	}
	return oldValue.Icon, nil
}

// ResetIcon resets all changes to the "icon" field.
func (m *ShopTypeMutation) ResetIcon() {
	m.icon = nil
}

// SetSort sets the "sort" field.
func (m *ShopTypeMutation) SetSort(i int) {
	m.sort = &i
	m.addsort = nil
}

// Sort returns the value of the "sort" field in the mutation.
func (m *ShopTypeMutation) Sort() (r int, exists bool) {
	v := m.sort
	if v == nil {
		return
	}
	return *v, true
}

// OldSort returns the old "sort" field's value of the ShopType entity.
// If the ShopType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ShopTypeMutation) OldSort(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSort is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSort requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSort: %w", err)
	}
	return oldValue.Sort, nil
}

// AddSort adds i to the "sort" field.
func (m *ShopTypeMutation) AddSort(i int) {
	if m.addsort != nil {
		*m.addsort += i
	} else {
		m.addsort = &i
	}
}

// AddedSort returns the value that was added to the "sort" field in this mutation.
func (m *ShopTypeMutation) AddedSort() (r int, exists bool) {
	v := m.addsort
	if v == nil {
		return
	}
	return *v, true
}

// ResetSort resets all changes to the "sort" field.
func (m *ShopTypeMutation) ResetSort() {
	m.sort = nil
	m.addsort = nil
}

// SetCreateTime sets the "createTime" field.
func (m *ShopTypeMutation) SetCreateTime(t time.Time) {
	m.createTime = &t
}

// CreateTime returns the value of the "createTime" field in the mutation.
func (m *ShopTypeMutation) CreateTime() (r time.Time, exists bool) {
	v := m.createTime
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "createTime" field's value of the ShopType entity.
// If the ShopType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ShopTypeMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "createTime" field.
func (m *ShopTypeMutation) ResetCreateTime() {
	m.createTime = nil
}

// SetUpdateTime sets the "updateTime" field.
func (m *ShopTypeMutation) SetUpdateTime(t time.Time) {
	m.updateTime = &t
}

// UpdateTime returns the value of the "updateTime" field in the mutation.
func (m *ShopTypeMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.updateTime
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "updateTime" field's value of the ShopType entity.
// If the ShopType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ShopTypeMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "updateTime" field.
func (m *ShopTypeMutation) ResetUpdateTime() {
	m.updateTime = nil
}

// Where appends a list predicates to the ShopTypeMutation builder.
func (m *ShopTypeMutation) Where(ps ...predicate.ShopType) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ShopTypeMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ShopTypeMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ShopType, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ShopTypeMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ShopTypeMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ShopType).
func (m *ShopTypeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ShopTypeMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.name != nil {
		fields = append(fields, shoptype.FieldName)
	}
	if m.icon != nil {
		fields = append(fields, shoptype.FieldIcon)
	}
	if m.sort != nil {
		fields = append(fields, shoptype.FieldSort)
	}
	if m.createTime != nil {
		fields = append(fields, shoptype.FieldCreateTime)
	}
	if m.updateTime != nil {
		fields = append(fields, shoptype.FieldUpdateTime)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ShopTypeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case shoptype.FieldName:
		return m.Name()
	case shoptype.FieldIcon:
		return m.Icon()
	case shoptype.FieldSort:
		return m.Sort()
	case shoptype.FieldCreateTime:
		return m.CreateTime()
	case shoptype.FieldUpdateTime:
		return m.UpdateTime()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ShopTypeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case shoptype.FieldName:
		return m.OldName(ctx)
	case shoptype.FieldIcon:
		return m.OldIcon(ctx)
	case shoptype.FieldSort:
		return m.OldSort(ctx)
	case shoptype.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case shoptype.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	}
	return nil, fmt.Errorf("unknown ShopType field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ShopTypeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case shoptype.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case shoptype.FieldIcon:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIcon(v)
		return nil
	case shoptype.FieldSort:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSort(v)
		return nil
	case shoptype.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case shoptype.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	}
	return fmt.Errorf("unknown ShopType field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ShopTypeMutation) AddedFields() []string {
	var fields []string
	if m.addsort != nil {
		fields = append(fields, shoptype.FieldSort)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ShopTypeMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case shoptype.FieldSort:
		return m.AddedSort()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ShopTypeMutation) AddField(name string, value ent.Value) error {
	switch name {
	case shoptype.FieldSort:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSort(v)
		return nil
	}
	return fmt.Errorf("unknown ShopType numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ShopTypeMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ShopTypeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ShopTypeMutation) ClearField(name string) error {
	return fmt.Errorf("unknown ShopType nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ShopTypeMutation) ResetField(name string) error {
	switch name {
	case shoptype.FieldName:
		m.ResetName()
		return nil
	case shoptype.FieldIcon:
		m.ResetIcon()
		return nil
	case shoptype.FieldSort:
		m.ResetSort()
		return nil
	case shoptype.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case shoptype.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	}
	return fmt.Errorf("unknown ShopType field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ShopTypeMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ShopTypeMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ShopTypeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ShopTypeMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ShopTypeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ShopTypeMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ShopTypeMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown ShopType unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ShopTypeMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown ShopType edge %s", name)
}

// UserMutation represents an operation that mutates the User nodes in the graph.
type UserMutation struct {
	config
	op            Op
	typ           string
	id            *uint64
	phone         *string
	password      *string
	nick_name     *string
	icon          *string
	create_time   *time.Time
	update_time   *time.Time
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*User, error)
	predicates    []predicate.User
}

var _ ent.Mutation = (*UserMutation)(nil)

// userOption allows management of the mutation configuration using functional options.
type userOption func(*UserMutation)

// newUserMutation creates new mutation for the User entity.
func newUserMutation(c config, op Op, opts ...userOption) *UserMutation {
	m := &UserMutation{
		config:        c,
		op:            op,
		typ:           TypeUser,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserID sets the ID field of the mutation.
func withUserID(id uint64) userOption {
	return func(m *UserMutation) {
		var (
			err   error
			once  sync.Once
			value *User
		)
		m.oldValue = func(ctx context.Context) (*User, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().User.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUser sets the old User of the mutation.
func withUser(node *User) userOption {
	return func(m *UserMutation) {
		m.oldValue = func(context.Context) (*User, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of User entities.
func (m *UserMutation) SetID(id uint64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserMutation) ID() (id uint64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserMutation) IDs(ctx context.Context) ([]uint64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().User.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetPhone sets the "phone" field.
func (m *UserMutation) SetPhone(s string) {
	m.phone = &s
}

// Phone returns the value of the "phone" field in the mutation.
func (m *UserMutation) Phone() (r string, exists bool) {
	v := m.phone
	if v == nil {
		return
	}
	return *v, true
}

// OldPhone returns the old "phone" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldPhone(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPhone is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPhone requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPhone: %w", err)
	}
	return oldValue.Phone, nil
}

// ResetPhone resets all changes to the "phone" field.
func (m *UserMutation) ResetPhone() {
	m.phone = nil
}

// SetPassword sets the "password" field.
func (m *UserMutation) SetPassword(s string) {
	m.password = &s
}

// Password returns the value of the "password" field in the mutation.
func (m *UserMutation) Password() (r string, exists bool) {
	v := m.password
	if v == nil {
		return
	}
	return *v, true
}

// OldPassword returns the old "password" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldPassword(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPassword is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPassword requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPassword: %w", err)
	}
	return oldValue.Password, nil
}

// ResetPassword resets all changes to the "password" field.
func (m *UserMutation) ResetPassword() {
	m.password = nil
}

// SetNickName sets the "nick_name" field.
func (m *UserMutation) SetNickName(s string) {
	m.nick_name = &s
}

// NickName returns the value of the "nick_name" field in the mutation.
func (m *UserMutation) NickName() (r string, exists bool) {
	v := m.nick_name
	if v == nil {
		return
	}
	return *v, true
}

// OldNickName returns the old "nick_name" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldNickName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNickName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNickName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNickName: %w", err)
	}
	return oldValue.NickName, nil
}

// ResetNickName resets all changes to the "nick_name" field.
func (m *UserMutation) ResetNickName() {
	m.nick_name = nil
}

// SetIcon sets the "icon" field.
func (m *UserMutation) SetIcon(s string) {
	m.icon = &s
}

// Icon returns the value of the "icon" field in the mutation.
func (m *UserMutation) Icon() (r string, exists bool) {
	v := m.icon
	if v == nil {
		return
	}
	return *v, true
}

// OldIcon returns the old "icon" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldIcon(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIcon is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIcon requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIcon: %w", err)
	}
	return oldValue.Icon, nil
}

// ResetIcon resets all changes to the "icon" field.
func (m *UserMutation) ResetIcon() {
	m.icon = nil
}

// SetCreateTime sets the "create_time" field.
func (m *UserMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *UserMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *UserMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *UserMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *UserMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *UserMutation) ResetUpdateTime() {
	m.update_time = nil
}

// Where appends a list predicates to the UserMutation builder.
func (m *UserMutation) Where(ps ...predicate.User) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UserMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UserMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.User, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UserMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UserMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (User).
func (m *UserMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.phone != nil {
		fields = append(fields, user.FieldPhone)
	}
	if m.password != nil {
		fields = append(fields, user.FieldPassword)
	}
	if m.nick_name != nil {
		fields = append(fields, user.FieldNickName)
	}
	if m.icon != nil {
		fields = append(fields, user.FieldIcon)
	}
	if m.create_time != nil {
		fields = append(fields, user.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, user.FieldUpdateTime)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case user.FieldPhone:
		return m.Phone()
	case user.FieldPassword:
		return m.Password()
	case user.FieldNickName:
		return m.NickName()
	case user.FieldIcon:
		return m.Icon()
	case user.FieldCreateTime:
		return m.CreateTime()
	case user.FieldUpdateTime:
		return m.UpdateTime()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case user.FieldPhone:
		return m.OldPhone(ctx)
	case user.FieldPassword:
		return m.OldPassword(ctx)
	case user.FieldNickName:
		return m.OldNickName(ctx)
	case user.FieldIcon:
		return m.OldIcon(ctx)
	case user.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case user.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	}
	return nil, fmt.Errorf("unknown User field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) SetField(name string, value ent.Value) error {
	switch name {
	case user.FieldPhone:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPhone(v)
		return nil
	case user.FieldPassword:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPassword(v)
		return nil
	case user.FieldNickName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNickName(v)
		return nil
	case user.FieldIcon:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIcon(v)
		return nil
	case user.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case user.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown User numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserMutation) ClearField(name string) error {
	return fmt.Errorf("unknown User nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserMutation) ResetField(name string) error {
	switch name {
	case user.FieldPhone:
		m.ResetPhone()
		return nil
	case user.FieldPassword:
		m.ResetPassword()
		return nil
	case user.FieldNickName:
		m.ResetNickName()
		return nil
	case user.FieldIcon:
		m.ResetIcon()
		return nil
	case user.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case user.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown User unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown User edge %s", name)
}

// VoucherMutation represents an operation that mutates the Voucher nodes in the graph.
type VoucherMutation struct {
	config
	op              Op
	typ             string
	id              *uint64
	shop_id         *uint64
	addshop_id      *int64
	title           *string
	sub_title       *string
	rules           *string
	pay_value       *uint64
	addpay_value    *int64
	actual_value    *int64
	addactual_value *int64
	_type           *int8
	add_type        *int8
	status          *int8
	addstatus       *int8
	create_time     *time.Time
	update_time     *time.Time
	clearedFields   map[string]struct{}
	getMore         map[uint64]struct{}
	removedgetMore  map[uint64]struct{}
	clearedgetMore  bool
	done            bool
	oldValue        func(context.Context) (*Voucher, error)
	predicates      []predicate.Voucher
}

var _ ent.Mutation = (*VoucherMutation)(nil)

// voucherOption allows management of the mutation configuration using functional options.
type voucherOption func(*VoucherMutation)

// newVoucherMutation creates new mutation for the Voucher entity.
func newVoucherMutation(c config, op Op, opts ...voucherOption) *VoucherMutation {
	m := &VoucherMutation{
		config:        c,
		op:            op,
		typ:           TypeVoucher,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withVoucherID sets the ID field of the mutation.
func withVoucherID(id uint64) voucherOption {
	return func(m *VoucherMutation) {
		var (
			err   error
			once  sync.Once
			value *Voucher
		)
		m.oldValue = func(ctx context.Context) (*Voucher, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Voucher.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withVoucher sets the old Voucher of the mutation.
func withVoucher(node *Voucher) voucherOption {
	return func(m *VoucherMutation) {
		m.oldValue = func(context.Context) (*Voucher, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m VoucherMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m VoucherMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Voucher entities.
func (m *VoucherMutation) SetID(id uint64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *VoucherMutation) ID() (id uint64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *VoucherMutation) IDs(ctx context.Context) ([]uint64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Voucher.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetShopID sets the "shop_id" field.
func (m *VoucherMutation) SetShopID(u uint64) {
	m.shop_id = &u
	m.addshop_id = nil
}

// ShopID returns the value of the "shop_id" field in the mutation.
func (m *VoucherMutation) ShopID() (r uint64, exists bool) {
	v := m.shop_id
	if v == nil {
		return
	}
	return *v, true
}

// OldShopID returns the old "shop_id" field's value of the Voucher entity.
// If the Voucher object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VoucherMutation) OldShopID(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldShopID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldShopID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldShopID: %w", err)
	}
	return oldValue.ShopID, nil
}

// AddShopID adds u to the "shop_id" field.
func (m *VoucherMutation) AddShopID(u int64) {
	if m.addshop_id != nil {
		*m.addshop_id += u
	} else {
		m.addshop_id = &u
	}
}

// AddedShopID returns the value that was added to the "shop_id" field in this mutation.
func (m *VoucherMutation) AddedShopID() (r int64, exists bool) {
	v := m.addshop_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetShopID resets all changes to the "shop_id" field.
func (m *VoucherMutation) ResetShopID() {
	m.shop_id = nil
	m.addshop_id = nil
}

// SetTitle sets the "title" field.
func (m *VoucherMutation) SetTitle(s string) {
	m.title = &s
}

// Title returns the value of the "title" field in the mutation.
func (m *VoucherMutation) Title() (r string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the Voucher entity.
// If the Voucher object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VoucherMutation) OldTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ResetTitle resets all changes to the "title" field.
func (m *VoucherMutation) ResetTitle() {
	m.title = nil
}

// SetSubTitle sets the "sub_title" field.
func (m *VoucherMutation) SetSubTitle(s string) {
	m.sub_title = &s
}

// SubTitle returns the value of the "sub_title" field in the mutation.
func (m *VoucherMutation) SubTitle() (r string, exists bool) {
	v := m.sub_title
	if v == nil {
		return
	}
	return *v, true
}

// OldSubTitle returns the old "sub_title" field's value of the Voucher entity.
// If the Voucher object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VoucherMutation) OldSubTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSubTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSubTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSubTitle: %w", err)
	}
	return oldValue.SubTitle, nil
}

// ResetSubTitle resets all changes to the "sub_title" field.
func (m *VoucherMutation) ResetSubTitle() {
	m.sub_title = nil
}

// SetRules sets the "rules" field.
func (m *VoucherMutation) SetRules(s string) {
	m.rules = &s
}

// Rules returns the value of the "rules" field in the mutation.
func (m *VoucherMutation) Rules() (r string, exists bool) {
	v := m.rules
	if v == nil {
		return
	}
	return *v, true
}

// OldRules returns the old "rules" field's value of the Voucher entity.
// If the Voucher object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VoucherMutation) OldRules(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRules is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRules requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRules: %w", err)
	}
	return oldValue.Rules, nil
}

// ResetRules resets all changes to the "rules" field.
func (m *VoucherMutation) ResetRules() {
	m.rules = nil
}

// SetPayValue sets the "pay_value" field.
func (m *VoucherMutation) SetPayValue(u uint64) {
	m.pay_value = &u
	m.addpay_value = nil
}

// PayValue returns the value of the "pay_value" field in the mutation.
func (m *VoucherMutation) PayValue() (r uint64, exists bool) {
	v := m.pay_value
	if v == nil {
		return
	}
	return *v, true
}

// OldPayValue returns the old "pay_value" field's value of the Voucher entity.
// If the Voucher object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VoucherMutation) OldPayValue(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPayValue is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPayValue requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPayValue: %w", err)
	}
	return oldValue.PayValue, nil
}

// AddPayValue adds u to the "pay_value" field.
func (m *VoucherMutation) AddPayValue(u int64) {
	if m.addpay_value != nil {
		*m.addpay_value += u
	} else {
		m.addpay_value = &u
	}
}

// AddedPayValue returns the value that was added to the "pay_value" field in this mutation.
func (m *VoucherMutation) AddedPayValue() (r int64, exists bool) {
	v := m.addpay_value
	if v == nil {
		return
	}
	return *v, true
}

// ResetPayValue resets all changes to the "pay_value" field.
func (m *VoucherMutation) ResetPayValue() {
	m.pay_value = nil
	m.addpay_value = nil
}

// SetActualValue sets the "actual_value" field.
func (m *VoucherMutation) SetActualValue(i int64) {
	m.actual_value = &i
	m.addactual_value = nil
}

// ActualValue returns the value of the "actual_value" field in the mutation.
func (m *VoucherMutation) ActualValue() (r int64, exists bool) {
	v := m.actual_value
	if v == nil {
		return
	}
	return *v, true
}

// OldActualValue returns the old "actual_value" field's value of the Voucher entity.
// If the Voucher object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VoucherMutation) OldActualValue(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldActualValue is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldActualValue requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldActualValue: %w", err)
	}
	return oldValue.ActualValue, nil
}

// AddActualValue adds i to the "actual_value" field.
func (m *VoucherMutation) AddActualValue(i int64) {
	if m.addactual_value != nil {
		*m.addactual_value += i
	} else {
		m.addactual_value = &i
	}
}

// AddedActualValue returns the value that was added to the "actual_value" field in this mutation.
func (m *VoucherMutation) AddedActualValue() (r int64, exists bool) {
	v := m.addactual_value
	if v == nil {
		return
	}
	return *v, true
}

// ResetActualValue resets all changes to the "actual_value" field.
func (m *VoucherMutation) ResetActualValue() {
	m.actual_value = nil
	m.addactual_value = nil
}

// SetType sets the "type" field.
func (m *VoucherMutation) SetType(i int8) {
	m._type = &i
	m.add_type = nil
}

// GetType returns the value of the "type" field in the mutation.
func (m *VoucherMutation) GetType() (r int8, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the Voucher entity.
// If the Voucher object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VoucherMutation) OldType(ctx context.Context) (v int8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// AddType adds i to the "type" field.
func (m *VoucherMutation) AddType(i int8) {
	if m.add_type != nil {
		*m.add_type += i
	} else {
		m.add_type = &i
	}
}

// AddedType returns the value that was added to the "type" field in this mutation.
func (m *VoucherMutation) AddedType() (r int8, exists bool) {
	v := m.add_type
	if v == nil {
		return
	}
	return *v, true
}

// ResetType resets all changes to the "type" field.
func (m *VoucherMutation) ResetType() {
	m._type = nil
	m.add_type = nil
}

// SetStatus sets the "status" field.
func (m *VoucherMutation) SetStatus(i int8) {
	m.status = &i
	m.addstatus = nil
}

// Status returns the value of the "status" field in the mutation.
func (m *VoucherMutation) Status() (r int8, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Voucher entity.
// If the Voucher object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VoucherMutation) OldStatus(ctx context.Context) (v int8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// AddStatus adds i to the "status" field.
func (m *VoucherMutation) AddStatus(i int8) {
	if m.addstatus != nil {
		*m.addstatus += i
	} else {
		m.addstatus = &i
	}
}

// AddedStatus returns the value that was added to the "status" field in this mutation.
func (m *VoucherMutation) AddedStatus() (r int8, exists bool) {
	v := m.addstatus
	if v == nil {
		return
	}
	return *v, true
}

// ResetStatus resets all changes to the "status" field.
func (m *VoucherMutation) ResetStatus() {
	m.status = nil
	m.addstatus = nil
}

// SetCreateTime sets the "create_time" field.
func (m *VoucherMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *VoucherMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the Voucher entity.
// If the Voucher object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VoucherMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *VoucherMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *VoucherMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *VoucherMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the Voucher entity.
// If the Voucher object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VoucherMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *VoucherMutation) ResetUpdateTime() {
	m.update_time = nil
}

// AddGetMoreIDs adds the "getMore" edge to the SeckillVoucher entity by ids.
func (m *VoucherMutation) AddGetMoreIDs(ids ...uint64) {
	if m.getMore == nil {
		m.getMore = make(map[uint64]struct{})
	}
	for i := range ids {
		m.getMore[ids[i]] = struct{}{}
	}
}

// ClearGetMore clears the "getMore" edge to the SeckillVoucher entity.
func (m *VoucherMutation) ClearGetMore() {
	m.clearedgetMore = true
}

// GetMoreCleared reports if the "getMore" edge to the SeckillVoucher entity was cleared.
func (m *VoucherMutation) GetMoreCleared() bool {
	return m.clearedgetMore
}

// RemoveGetMoreIDs removes the "getMore" edge to the SeckillVoucher entity by IDs.
func (m *VoucherMutation) RemoveGetMoreIDs(ids ...uint64) {
	if m.removedgetMore == nil {
		m.removedgetMore = make(map[uint64]struct{})
	}
	for i := range ids {
		delete(m.getMore, ids[i])
		m.removedgetMore[ids[i]] = struct{}{}
	}
}

// RemovedGetMore returns the removed IDs of the "getMore" edge to the SeckillVoucher entity.
func (m *VoucherMutation) RemovedGetMoreIDs() (ids []uint64) {
	for id := range m.removedgetMore {
		ids = append(ids, id)
	}
	return
}

// GetMoreIDs returns the "getMore" edge IDs in the mutation.
func (m *VoucherMutation) GetMoreIDs() (ids []uint64) {
	for id := range m.getMore {
		ids = append(ids, id)
	}
	return
}

// ResetGetMore resets all changes to the "getMore" edge.
func (m *VoucherMutation) ResetGetMore() {
	m.getMore = nil
	m.clearedgetMore = false
	m.removedgetMore = nil
}

// Where appends a list predicates to the VoucherMutation builder.
func (m *VoucherMutation) Where(ps ...predicate.Voucher) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the VoucherMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *VoucherMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Voucher, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *VoucherMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *VoucherMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Voucher).
func (m *VoucherMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *VoucherMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.shop_id != nil {
		fields = append(fields, voucher.FieldShopID)
	}
	if m.title != nil {
		fields = append(fields, voucher.FieldTitle)
	}
	if m.sub_title != nil {
		fields = append(fields, voucher.FieldSubTitle)
	}
	if m.rules != nil {
		fields = append(fields, voucher.FieldRules)
	}
	if m.pay_value != nil {
		fields = append(fields, voucher.FieldPayValue)
	}
	if m.actual_value != nil {
		fields = append(fields, voucher.FieldActualValue)
	}
	if m._type != nil {
		fields = append(fields, voucher.FieldType)
	}
	if m.status != nil {
		fields = append(fields, voucher.FieldStatus)
	}
	if m.create_time != nil {
		fields = append(fields, voucher.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, voucher.FieldUpdateTime)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *VoucherMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case voucher.FieldShopID:
		return m.ShopID()
	case voucher.FieldTitle:
		return m.Title()
	case voucher.FieldSubTitle:
		return m.SubTitle()
	case voucher.FieldRules:
		return m.Rules()
	case voucher.FieldPayValue:
		return m.PayValue()
	case voucher.FieldActualValue:
		return m.ActualValue()
	case voucher.FieldType:
		return m.GetType()
	case voucher.FieldStatus:
		return m.Status()
	case voucher.FieldCreateTime:
		return m.CreateTime()
	case voucher.FieldUpdateTime:
		return m.UpdateTime()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *VoucherMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case voucher.FieldShopID:
		return m.OldShopID(ctx)
	case voucher.FieldTitle:
		return m.OldTitle(ctx)
	case voucher.FieldSubTitle:
		return m.OldSubTitle(ctx)
	case voucher.FieldRules:
		return m.OldRules(ctx)
	case voucher.FieldPayValue:
		return m.OldPayValue(ctx)
	case voucher.FieldActualValue:
		return m.OldActualValue(ctx)
	case voucher.FieldType:
		return m.OldType(ctx)
	case voucher.FieldStatus:
		return m.OldStatus(ctx)
	case voucher.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case voucher.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	}
	return nil, fmt.Errorf("unknown Voucher field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *VoucherMutation) SetField(name string, value ent.Value) error {
	switch name {
	case voucher.FieldShopID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetShopID(v)
		return nil
	case voucher.FieldTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case voucher.FieldSubTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSubTitle(v)
		return nil
	case voucher.FieldRules:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRules(v)
		return nil
	case voucher.FieldPayValue:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPayValue(v)
		return nil
	case voucher.FieldActualValue:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetActualValue(v)
		return nil
	case voucher.FieldType:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case voucher.FieldStatus:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case voucher.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case voucher.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	}
	return fmt.Errorf("unknown Voucher field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *VoucherMutation) AddedFields() []string {
	var fields []string
	if m.addshop_id != nil {
		fields = append(fields, voucher.FieldShopID)
	}
	if m.addpay_value != nil {
		fields = append(fields, voucher.FieldPayValue)
	}
	if m.addactual_value != nil {
		fields = append(fields, voucher.FieldActualValue)
	}
	if m.add_type != nil {
		fields = append(fields, voucher.FieldType)
	}
	if m.addstatus != nil {
		fields = append(fields, voucher.FieldStatus)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *VoucherMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case voucher.FieldShopID:
		return m.AddedShopID()
	case voucher.FieldPayValue:
		return m.AddedPayValue()
	case voucher.FieldActualValue:
		return m.AddedActualValue()
	case voucher.FieldType:
		return m.AddedType()
	case voucher.FieldStatus:
		return m.AddedStatus()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *VoucherMutation) AddField(name string, value ent.Value) error {
	switch name {
	case voucher.FieldShopID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddShopID(v)
		return nil
	case voucher.FieldPayValue:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPayValue(v)
		return nil
	case voucher.FieldActualValue:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddActualValue(v)
		return nil
	case voucher.FieldType:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddType(v)
		return nil
	case voucher.FieldStatus:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatus(v)
		return nil
	}
	return fmt.Errorf("unknown Voucher numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *VoucherMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *VoucherMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *VoucherMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Voucher nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *VoucherMutation) ResetField(name string) error {
	switch name {
	case voucher.FieldShopID:
		m.ResetShopID()
		return nil
	case voucher.FieldTitle:
		m.ResetTitle()
		return nil
	case voucher.FieldSubTitle:
		m.ResetSubTitle()
		return nil
	case voucher.FieldRules:
		m.ResetRules()
		return nil
	case voucher.FieldPayValue:
		m.ResetPayValue()
		return nil
	case voucher.FieldActualValue:
		m.ResetActualValue()
		return nil
	case voucher.FieldType:
		m.ResetType()
		return nil
	case voucher.FieldStatus:
		m.ResetStatus()
		return nil
	case voucher.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case voucher.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	}
	return fmt.Errorf("unknown Voucher field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *VoucherMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.getMore != nil {
		edges = append(edges, voucher.EdgeGetMore)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *VoucherMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case voucher.EdgeGetMore:
		ids := make([]ent.Value, 0, len(m.getMore))
		for id := range m.getMore {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *VoucherMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedgetMore != nil {
		edges = append(edges, voucher.EdgeGetMore)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *VoucherMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case voucher.EdgeGetMore:
		ids := make([]ent.Value, 0, len(m.removedgetMore))
		for id := range m.removedgetMore {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *VoucherMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedgetMore {
		edges = append(edges, voucher.EdgeGetMore)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *VoucherMutation) EdgeCleared(name string) bool {
	switch name {
	case voucher.EdgeGetMore:
		return m.clearedgetMore
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *VoucherMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Voucher unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *VoucherMutation) ResetEdge(name string) error {
	switch name {
	case voucher.EdgeGetMore:
		m.ResetGetMore()
		return nil
	}
	return fmt.Errorf("unknown Voucher edge %s", name)
}
